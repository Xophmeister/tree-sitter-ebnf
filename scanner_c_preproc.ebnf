/*ignore*/ COMMENT ::= ("/*"([^\*]|("*"+[^\*/]))*"*"+"/")|("//"[^\n]*)

/*ignore*/ DIRECTIVE_CONTINUE ::= "\\\n"

DIRECTIVE_END ::= "\n"

DEFINE ::= "#define"
DEFINED ::= "defined"
UNDEF ::= "#undef"
INCLUDE ::= "#include"
IF ::= "#if"
IFDEF ::= "#ifdef"
IFNDEF ::= "#ifndef"
ELSE ::= "#else"
ELIF ::= "#elif"
ENDIF ::= "#endif"

LINE ::= "#line"
ERROR ::= "#error"
WARNING ::= "#warning"
PRAGMA ::= "#pragma"

IDENTIFIER ::= [_a-zA-Z][_a-zA-Z0-9]*

/*
 * MACRO is a workaround becouse in the expression
 * #define a (b) c
 * if there is a whitespace between a and (b), it is a ordinary define
 * if there is no whitespace, then it's a macro,
 * as our lexer ignores whitespaces, we define the token MACRO
 * that is an identifier with a '(' in the end
*/
MACRO ::= [_a-zA-Z][_a-zA-Z0-9]*

CONSTANT ::= "0"[xX]([0-9a-fA-F])+[uUlL]?
CONSTANT ::= [0-9]+[uUlL]?
CONSTANT ::= "'"([^\']|"\'")+"'"

CONSTANT ::= [0-9]+[eE][\+-]?[0-9]+[fFlL]?
CONSTANT ::= [0-9]+'.'[0-9]*([eE][\+-]?)?[0-9]+[fFlL]?
CONSTANT ::= [0-9]*'.'[0-9]+([eE][\+-]?)?[0-9]+[fFlL]?

FILENAME_SYSTEM ::= "<" [^>]* ">"
STRING_LITERAL ::= '"' ([^\"]|'\"')* '"'

ELLIPSIS ::= "..."
RIGHT_ASSIGN ::= ">>="
LEFT_ASSIGN ::= "<<="
ADD_ASSIGN ::= "+="
SUB_ASSIGN ::= "-="
MUL_ASSIGN ::= "*="
DIV_ASSIGN ::= "/="
MOD_ASSIGN ::= "%="
AND_ASSIGN ::= "&="
XOR_ASSIGN ::= "^="
OR_ASSIGN ::= "|="

RIGHT_OP ::= ">>"
LEFT_OP ::= "<<"
INC_OP ::= "++"
DEC_OP ::= "--"
PTR_OP ::= "->"
AND_OP ::= "&&"
OR_OP ::= "||"
LE_OP ::= "<="
GE_OP ::= ">="
EQ_OP ::= "=="
NE_OP ::= "!="

INST_END ::= ";"
BEGIN ::= "{"
END ::= "}"
COMMA ::= ","
COLUMN ::= ":"
EQ ::= "="
P_OPEN ::= "("
P_CLOSE ::= ")"
B_OPEN ::= "["
B_CLOSE ::= "]"
DOT ::= "."
AND ::= "&"
NOT ::= "!"
NEG ::= "~"
LESS_SIG ::= "-"
PLUS_SIG ::= "+"
MUL ::= "*"
DIV ::= "/"
MOD ::= "%"
LESS ::= "<"
GREATER ::= ">"
XOR ::= "^"
OR ::= "|"
QUESTION ::= "?"

/*ignore*/ WHITESPCE ::= "[ \t\f\r]+"

// the text will be generated by PreprocessorScanner.
// define it's regex to be never used here
TEXT ::= " "
